(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{568:function(r,t,o){"use strict";o.r(t);var n=o(17),a=Object(n.a)({},(function(){var r=this,t=r._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h1",{attrs:{id:"ioc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ioc"}},[r._v("#")]),r._v(" IoC")]),r._v(" "),t("p",[t("strong",[r._v("IoC(Inversion of Control, 제어의 역전)")]),r._v(" 이라고 함.")]),r._v(" "),t("ul",[t("li",[r._v("객체의 생성, 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀌었다는 것을 의미한다.")]),r._v(" "),t("li",[r._v("컴포넌트 의존관계 설정, Configuration 및 생명주기를 해결하기위한 디자인패턴")])]),r._v(" "),t("p",[r._v("기존의 자바 기반으로 어플리케이션을 개발할 때 자바 객체를 생성하고 서로간의 의존관계를 개발자가 직접 제어했었는데 servlet이나 EJB를 사용하는 경우 각 컨테이너에게 제어권이 넘어가서 객체의 생명주기를 해당 Containere들이 전담하게된다.")]),r._v(" "),t("p",[r._v("다시 말해서 제어의 역전이란 인스턴스 생성부터 소멸까지의 인스턴스 생명주기 관리 등을 개발자가 아닌 컨테이너가 대신 해준다는 뜻이다.")]),r._v(" "),t("p",[r._v("예를들어 어떠한 Library를 사용하고 싶다고 가정한다면 개발자는 이를 사용하기 위해서 Library를 호출한다. 이때에는 개발자가 주도권을 가지고 있는 상태인 것이다. 반면 SpringFramework에서 IoC는 프레임 워크 내에 Library가 구성되어있고 프레임 워크에서 개발자가 작성한 코드를 호출하기 때문에 주도권은 FrameWork에게 있게 된다.")])])}),[],!1,null,null,null);t.default=a.exports}}]);