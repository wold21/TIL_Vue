(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{477:function(t,e,r){t.exports=r.p+"assets/img/reliable_protocol.f55f768d.png"},478:function(t,e,r){t.exports=r.p+"assets/img/bite-stream,message-oriented.8d0e5266.png"},552:function(t,e,r){"use strict";r.r(e);var o=r(17),a=Object(o.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"byte-stream-protocol과-message-oriented-protocol의-차이"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#byte-stream-protocol과-message-oriented-protocol의-차이"}},[t._v("#")]),t._v(" byte-stream protocol과 message-oriented protocol의 차이")]),t._v(" "),e("h2",{attrs:{id:"개요"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#개요"}},[t._v("#")]),t._v(" 개요")]),t._v(" "),e("p",[t._v("TCP와 UDP를 각각 byte-stream protocol과 message-oriented protocol이라고 부른다. 그 이유와 동작 방식에 대해서 알아보려고 한다.")]),t._v(" "),e("h2",{attrs:{id:"udp-message-oriented-protocol"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#udp-message-oriented-protocol"}},[t._v("#")]),t._v(" UDP - message-oriented protocol")]),t._v(" "),e("p",[t._v("UDP는 internet protocol과 거의 유사하게 동작하기 때문에 전송 중 데이터가 유실되거나 순서가 바뀌는 경우가 발생하나, 그런 문제없이 잘 전달된다고 가정을 해보겠다.")]),t._v(" "),e("p",[t._v("한 호스트에서 다른 호스트로 각각 4byte, 8byte, 3byte의 데이터를 보내면 도착지 호스트의 transport layer에서 메시지를 잘 구분하여 application layer로 데이터를 잘 보내주게 된다. 이때 출발지 호스트에서 전송 함수를 통해 각 3개의 "),e("code",[t._v("메시지")]),t._v("를 보내면 받는 쪽에서도 받는 함수를 3번 호출하여 메시지를 읽게 되게되는데 이게 message-oriented protocol의 큰 특징이다.")]),t._v(" "),e("ul",[e("li",[t._v("보낸 메시지 단위 그대로 받을 수 있게 해주는 프로토콜")]),t._v(" "),e("li",[t._v("메시지 간의 경계를 구분할 수 있음")]),t._v(" "),e("li",[t._v("한번에 전송 가능한 메시지의 최대 크기가 존재함")])]),t._v(" "),e("h2",{attrs:{id:"tcp-byte-stream-protocol"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp-byte-stream-protocol"}},[t._v("#")]),t._v(" TCP - byte-stream protocol")]),t._v(" "),e("p",[t._v("TCP는 UDP처럼 4byte, 8byte, 3byte와 같은 데이터를 보낼 때 메시지의 경계나 구분에 관심이 없고 보내려는 데이터를 byte들의 흐름이라고 인식하고 전송합니다. 그러면 TCP는 이 byte들을 어떤 단위로 전송할까. 바로 이전에 배웠던 TCP segment이다. 정리해보자면")]),t._v(" "),e("ul",[e("li",[t._v("TCP는 신뢰할 수 있는 데이터 전송을 실현하는 것이 목적이다.")]),t._v(" "),e("li",[t._v("애플리케이션에서 보낸 메시지와는 독립적으로 특정 크기로 구분되는 별도의 전송단위를 통해 데이터를 전송한다.")]),t._v(" "),e("li",[t._v("이 단위를 "),e("code",[t._v("TCP segment")]),t._v("라고 부른다.")]),t._v(" "),e("li",[t._v("특정크기에 대한 개념은 다음과 같다.\n"),e("ul",[e("li",[e("code",[t._v("MSS(Maximum Segment Size)")])]),t._v(" "),e("li",[t._v("정의한 MSS값보다 크면 segment를 분리한다.")])])])]),t._v(" "),e("p",[t._v("그런데 만약 MSS의 크기가 널널해서 15byte를 한번에 보낼 수 있게 되었고 해당 데이터를 도착지 애플리케이션에서 사용하면 된다. 아까는 클라이언트에서 3번에 나누어 데이터를 보내고 받았는데 TCP로 보낼 때 또한 출발지 호스트는 3번에 나누어 보냈다. 그런데 MSS의 값이 널널해서 한번에 보냈는데 그럼 받는 쪽에서는 메시지를 어떻게 구분해야할까? 이때 이 책임은 byte-stream protocol에 있지 않다. 이 프로토콜을 사용하는 쪽에서 담당한다고 한다. 예를들어 MSS가 1kb라면 최대 1kb만큼의 byte를 한번에 읽을 수 있다는 것이다. 동작을 좀 더 정리해보면")]),t._v(" "),e("ul",[e("li",[t._v("사용하는 쪽에서 전송한 메시지를 구분하지 않음")]),t._v(" "),e("li",[t._v("데이터 전송을 "),e("code",[t._v("byte들의 흐름 관점")]),t._v("으로만 접근")]),t._v(" "),e("li",[e("code",[t._v("메시지를 구분하는 책임은 해당 프로토콜을 사용하는 쪽에 있음")])])]),t._v(" "),e("h2",{attrs:{id:"질문"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#질문"}},[t._v("#")]),t._v(" 질문")]),t._v(" "),e("p",[e("b",[t._v("1. Byte-stream protocol은 reliable한가?")]),e("br"),t._v("\nreliable한지 여부와 독립적인 개념이다.\n"),e("img",{attrs:{src:r(477),alt:"reliable_protocol",height:"150"}})]),t._v(" "),e("p",[e("b",[t._v("2. UDP를 통해 max UDP datagram size보다 큰 메시지를 전송하려면 어떻게 되는가?")])]),t._v(" "),e("p",[t._v("이때는 실패하고 에러를 받는다. 에러에 대해서 어떻게 처리할지는 개발자나 application-layer protocol이 구현해야한다.")]),t._v(" "),e("p",[e("b",[t._v("3. TCP를 통해 MSS보다 큰 메시지를 전송하려면 어떻게 되는가?")]),e("br"),t._v("\nTCP가 알아서 MSS에 맞는 TCP segment로 나누어서 전송한다.")]),t._v(" "),e("p",[e("b",[t._v("4. byte-stream protocol을 사용하는 쪽에서 메시지를 구분하는 방법은 어떤 것들이 있나요?")]),e("br"),t._v("\n방법은 여러가지가 있다.")]),t._v(" "),e("ul",[e("li",[t._v("메시지 사이즈를 고정한다.")]),t._v(" "),e("li",[t._v("메시지 사이즈를 먼저 보낸 후 메시지를 보낸다.")]),t._v(" "),e("li",[t._v("메시지 사이에 구분자를 넣어서 전송한다. (ex. CRLF)\n"),e("ul",[e("li",[t._v("Carriage Return / Line Feed")])])])]),t._v(" "),e("p",[e("b",[t._v("5. TCP가 byte-stream protocol이라면 TCP 위에서 동작하는 HTTP는 자체적으로 HTTP message의 경계를 구분하는 방법을 가지고 있다는 말인가?")]),e("br"),t._v("\n정답은 그렇다. 그러나 HTTP버전에 따라 달라지는 부분이 있기 때문에 사용하는 버전에 따라 확인해봐야한다.")]),t._v(" "),e("h2",{attrs:{id:"마무리"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#마무리"}},[t._v("#")]),t._v(" 마무리")]),t._v(" "),e("img",{attrs:{src:r(478),alt:"bite-stream,message-oriented",height:"300"}})])}),[],!1,null,null,null);e.default=a.exports}}]);