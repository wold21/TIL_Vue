(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{572:function(t,a,r){"use strict";r.r(a);var e=r(25),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"entity-manager-factory-entity-manager-transaction-jpql"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#entity-manager-factory-entity-manager-transaction-jpql"}},[t._v("#")]),t._v(" Entity Manager Factory & Entity Manager & Transaction & JPQL")]),t._v(" "),r("h3",{attrs:{id:"엔티티-매니저-팩토리-생성"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#엔티티-매니저-팩토리-생성"}},[t._v("#")]),t._v(" 엔티티 매니저 팩토리 생성")]),t._v(" "),r("p",[t._v("팩토리를 선언하면 jpa를 동작시키기 위한 기반 객체를 만들고 jpa 구현체에 따라서는 db커넥션 풀도 생성한다. 그렇기에 팩토리 하나를 생성하는 비용이 크기 때문에 어플리케이션 전체에 한번 생성하여 사용하여야한다.")]),t._v(" "),r("h3",{attrs:{id:"엔티티-매니저-생성"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#엔티티-매니저-생성"}},[t._v("#")]),t._v(" 엔티티 매니저 생성")]),t._v(" "),r("p",[t._v("대부분의 jpa기능은 이 매니저가 제공한다. 기본적인 crud를 제공하는 곳이  엔티티 매니저이다. 매니저는 내부에 db소스(커넥션)를 유지하면서 db와 통신한다. 따라서 개발자는 매니저를 가상의 db로 생각해볼 수도 있겠다. 주의할 점은 db 커넥션과 밀접한 관계가 있으므로 스레트 간에 공유하거나 재사용하면 안된다.")]),t._v(" "),r("h3",{attrs:{id:"트랜잭션-관리"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#트랜잭션-관리"}},[t._v("#")]),t._v(" 트랜잭션 관리")]),t._v(" "),r("p",[t._v("jpa를 사용하면 항상 트랜잭션 안에서 데이터를 변경해야한다. 트랜잭션 없이 데이터를 변경하면 예외가 발생한다.")]),t._v(" "),r("h3",{attrs:{id:"jpql"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jpql"}},[t._v("#")]),t._v(" JPQL")]),t._v(" "),r("p",[t._v("기본적인 CRUD는 제공을 해주지만 검색과 같은 동적 쿼리는 JPA에서 어떻게 처리할까? 그런데 테이블이 아닌 엔티티 객체를 대상으로 검색을 하려고 하면 모든 객체를 애플리케이션 내로 가져와서 검색을 해야할 것이다. JPA는 이때 JPQL이라는 객체지향 쿼리 언어를 사용하여 문제를 해결한다. 기존 SQL과 다른 점은 대상이 테이블이냐 객체이냐의 차이일 것이다.")])])}),[],!1,null,null,null);a.default=s.exports}}]);