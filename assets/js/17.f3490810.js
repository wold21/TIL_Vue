(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{377:function(t,e,a){t.exports=a.p+"assets/img/fd_0.51207474.png"},378:function(t,e,a){t.exports=a.p+"assets/img/fd_1.ad4ecb86.png"},379:function(t,e,a){t.exports=a.p+"assets/img/fd_2.70e48618.png"},380:function(t,e,a){t.exports=a.p+"assets/img/fd_3.5a134f0c.png"},381:function(t,e,a){t.exports=a.p+"assets/img/fd_4.bcb9729e.png"},382:function(t,e,a){t.exports=a.p+"assets/img/fd_5.efed68c7.png"},383:function(t,e,a){t.exports=a.p+"assets/img/fd_6.08a3404c.png"},384:function(t,e,a){t.exports=a.p+"assets/img/fd_7.aa5f0392.png"},510:function(t,e,a){"use strict";a.r(e);var n=a(17),s=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"functional-dependency-함수-종속"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#functional-dependency-함수-종속"}},[t._v("#")]),t._v(" Functional Dependency(함수 종속)")]),t._v(" "),e("h2",{attrs:{id:"개요"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#개요"}},[t._v("#")]),t._v(" 개요")]),t._v(" "),e("p",[t._v("Functional Dependency의 의미는 한 테이블에 있는 두 개의 attribute(s) 집합(set)사이의 제약(a constraint)를 말한다.\n"),e("br"),t._v(" "),e("img",{attrs:{src:a(377),alt:"fd_0",height:"300"}})]),t._v(" "),e("p",[t._v("이러한 테이블이 있을 때 특징은 두 개 tuple의 X값이 같다면 Y값도 같다는 특징이 있다. 이유는 empl_id를 통해 유니크하게 주어진 ID이기 때문이다.\n"),e("br"),t._v(" "),e("img",{attrs:{src:a(378),alt:"fd_1",height:"300"}})]),t._v(" "),e("p",[t._v("이때 X 값에 따라 Y값이 유일하게 결정될 때 이를 "),e("code",[t._v("X가 Y를 함수적으로 결정한다")]),t._v("라고 하며 "),e("code",[t._v("Y가 X에 함수적으로 의존한다")]),t._v("라고도 말할 수 있다. 두 집합 사이의 이러한 제약 관계를 "),e("code",[t._v("functional dependency(FD)")]),t._v("라고 부른다. 기호로는 "),e("code",[t._v("X(left hand side) -> Y(right hand side)")]),t._v("로 표현한다. 집합 X가 Y를 결정한다라는 뜻이다.")]),t._v(" "),e("h2",{attrs:{id:"functional-dependency-파악하기"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#functional-dependency-파악하기"}},[t._v("#")]),t._v(" Functional dependency 파악하기")]),t._v(" "),e("p",[t._v("테이블의 스키마를 보고 "),e("code",[t._v("의미적으로")]),t._v(" 파악해야한다. 즉, 테이블의 state를 보고 FD를 파악해서는 안된다.\n"),e("br"),t._v(" "),e("img",{attrs:{src:a(379),alt:"fd_2",height:"300"}})]),t._v(" "),e("p",[t._v('예를들면 5번째 라인의 진호라는 사람이 입사하기 전에 이름과 생년월일을 살펴보았더니 이름이 마치 생일을 결정하는 것처럼 보여 "아 이름이 생일을 결정하는 구나." 라고 생각할 수 있는데 ('),e("code",[t._v("{empl_name} -> {birth_date}")]),t._v(") 5번째의 진호가 들어오는 순간 바로 성립되지 않아버리기 때문이다. 그래서 FD는 테이블의 특정 순간의 특정 상태를 보고 판단하면 안된다.\n"),e("br"),t._v(" "),e("img",{attrs:{src:a(380),alt:"fd_3",height:"300"}})]),t._v(" "),e("h3",{attrs:{id:"또-다른-예시"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#또-다른-예시"}},[t._v("#")]),t._v(" 또 다른 예시")]),t._v(" "),e("p",[t._v("만약 집합 Y가 dept_id까지 포함한다면 FD는 어떻게 될까. 이때는 정말 의미적으로 생각해봐야한다. 예를 들면 이 회사가 한 직원이 여러 부서에 속해 있을 수 있는지 아닌지에 따라 달라지게 되는 것이다. 여러 부서에 속할 수 있다면 FD가 성립되지 않을 것이기 때문이다.\n"),e("br"),t._v(" "),e("img",{attrs:{src:a(381),alt:"fd_4",height:"300"}})]),t._v(" "),e("br"),t._v(" "),e("img",{attrs:{src:a(382),alt:"fd_5",height:"300"}}),t._v(" "),e("h3",{attrs:{id:"x-y-not-means-y-x"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#x-y-not-means-y-x"}},[t._v("#")]),t._v(" X -> Y not means Y -> X")]),t._v(" "),e("p",[t._v("X가 Y를 결정짓는다고 해서 Y가 X를 결정 지을 수는 없으며 반드시 결정하지 못한다는 법이 없다.")]),t._v(" "),e("h3",{attrs:{id:"y"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#y"}},[t._v("#")]),t._v(" {} -> Y")]),t._v(" "),e("p",[t._v("해당 의미는 Y값은 언제나 하나의 값만을 가진다는 의미를 가지고 있다.\n"),e("br"),t._v(" "),e("img",{attrs:{src:a(383),alt:"fd_6",height:"250"}}),e("br"),t._v("\n이런 경우에 위와 같이 표현한다.")]),t._v(" "),e("h2",{attrs:{id:"fd의-종류"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fd의-종류"}},[t._v("#")]),t._v(" FD의 종류")]),t._v(" "),e("h3",{attrs:{id:"trivial-functional-dependency"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#trivial-functional-dependency"}},[t._v("#")]),t._v(" Trivial functional dependency")]),t._v(" "),e("p",[t._v("when X -> Y holds, if Y is subset of X, then X -> Y is trivial FD\nX가 Y를 결정할 때 만약 Y가 X의 부분 집합이라면 이때 X -> Y를 trivial FD라고 하는 것이다."),e("br"),t._v(" "),e("code",[t._v("{a, b, c} -> { c } is trivial FD")]),e("br"),t._v(" "),e("code",[t._v("{a, b, c} -> { a, c } is trivial FD")]),e("br"),t._v(" "),e("code",[t._v("{a, b, c} -> { a, b, c } is trivial FD")])]),t._v(" "),e("h3",{attrs:{id:"non-trivial-functional-dependency"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#non-trivial-functional-dependency"}},[t._v("#")]),t._v(" Non-trivial functional dependency")]),t._v(" "),e("p",[t._v("when X -> Y holds, if Y is NOT subset of X, then X -> Y is non-trivial FD\nX가 Y를 결정할 때 만약 Y가 X의 부분집합이 아니라면 이때 X -> Y를 non-trivial FD라 한다."),e("br"),t._v(" "),e("code",[t._v("{a, b, d} -> { b, c, d } is non-trivial FD")]),e("br"),t._v(" "),e("code",[t._v("{a, b, d} -> { d, e } is non-trivial FD & completely non-trivial FD")])]),t._v(" "),e("h3",{attrs:{id:"partial-functional-dependency"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#partial-functional-dependency"}},[t._v("#")]),t._v(" Partial functional dependency")]),t._v(" "),e("p",[t._v("when X -> Y holds, if 'any proper subset of X' can determine Y, then X -> Y is partial FD\nX가 Y를 결정할 때 X의 proper 부분집합이 Y를 결정 지을 수 있다면 이때 X -> Y를 partial FD라 한다."),e("br"),t._v(" "),e("br"),t._v(" "),e("img",{attrs:{src:a(384),alt:"fd_7",height:"250"}})]),t._v(" "),e("div",{staticClass:"language-TEXT extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("when {empl_id, empl_name} -> {birth_date} holds,  \nbecuase {empl_id} can determine {birth_date},  \nthen this FD is partial FD\n")])])]),e("h3",{attrs:{id:"full-functional-dependency"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#full-functional-dependency"}},[t._v("#")]),t._v(" Full functional dependency")]),t._v(" "),e("p",[t._v("when X -> Y holds,\nif 'every proper subset of X' can NOT determine Y, then X -> Y is full FD")]),t._v(" "),e("div",{staticClass:"language-TEXT extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("when {stu_id, class_id} -> {grade} holds,\nbecause {stu_id}, {class_id}, {} can NOT determine {grade},\nthen this FD is full FD\n")])])]),e("h2",{attrs:{id:"마무리"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#마무리"}},[t._v("#")]),t._v(" 마무리")]),t._v(" "),e("p",[t._v("해당 개념들은 정규화를 위해서 알고 가야할 개념들이다. 정규화에 대해서 두 번정도 공부했던 것 같은데 아마 이번에는 조금 다른 방식으로 배울 수 있지 않을까 생각이 된다. 내개 남아있는 정규화의 개념은 "),e("code",[t._v("정규화의 방식(공식)은 총 5개로 이루어져있다.")]),t._v("라는 것 밖엔 남아있지 않다.")])])}),[],!1,null,null,null);e.default=s.exports}}]);