(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{465:function(t,a,e){t.exports=e.p+"assets/img/cartesian_product.85cc736c.png"},466:function(t,a,e){t.exports=e.p+"assets/img/binary_relation.0bdc29d5.png"},467:function(t,a,e){t.exports=e.p+"assets/img/n_ary_relation.b15b1b43.png"},468:function(t,a,e){t.exports=e.p+"assets/img/math_in_relation.6fdd9114.png"},469:function(t,a,e){t.exports=e.p+"assets/img/attribute.e2e8af1f.png"},470:function(t,a,e){t.exports=e.p+"assets/img/tuple.825e57a6.png"},471:function(t,a,e){t.exports=e.p+"assets/img/student_relation.0652cd2e.png"},472:function(t,a,e){t.exports=e.p+"assets/img/conclusion.093036f2.png"},552:function(t,a,e){"use strict";e.r(a);var i=e(25),r=Object(i.a)({},(function(){var t=this,a=t.$createElement,i=t._self._c||a;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h1",{attrs:{id:"관계형-데이터베이스"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#관계형-데이터베이스"}},[t._v("#")]),t._v(" 관계형 데이터베이스")]),t._v(" "),i("h2",{attrs:{id:"개요"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#개요"}},[t._v("#")]),t._v(" 개요")]),t._v(" "),i("p",[t._v("relational이 무엇인지 알기 위해서는 먼저 set이라는 자료구조를 알 필요가 있다.")]),t._v(" "),i("blockquote",[i("p",[t._v("set이란?"),i("br"),t._v("\n서로 다른 elements를 가지는 collection이며 하나의 set에서 elements의 순서는 중요하지 않다.")])]),t._v(" "),i("h2",{attrs:{id:"수학에서-relation이란"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#수학에서-relation이란"}},[t._v("#")]),t._v(" 수학에서 relation이란?")]),t._v(" "),i("img",{attrs:{src:e(465),alt:"cartesian_product",height:"250"}}),t._v(" "),i("ul",[i("li",[t._v("수학에서 말하는 릴레이션은 cartesian product와 관련이 있다. cartesian product은 집합 a과 b에서 각각 하나씩 골랐을 때 만들 수 있는 모든 조합을 의미한다.")])]),t._v(" "),i("img",{attrs:{src:e(466),alt:"binary_relation",height:"250"}}),t._v(" "),i("ul",[i("li",[t._v("이런 경우의 릴레이션을 binary relation이라하고 A와 B의 cartesian product의 부분 집합이라 말할 수 있다.")]),t._v(" "),i("li",[t._v("그리고 이것이 수학에서 말하는 관계이다.")])]),t._v(" "),i("img",{attrs:{src:e(467),alt:"n_ary_relation",height:"250"}}),t._v(" "),i("ul",[i("li",[t._v("위의 set이 확장되었다고 생각해보자.")]),t._v(" "),i("li",[t._v("이 전에는 집합이 두개라 바이너리였지만 지금은 집합이 n개이기 때문에 n-ary 릴레이션이라고 한다.")]),t._v(" "),i("li",[t._v("n-ary 릴레이션은 n개의 cartesian product의 부분 집합이라고 할 수 있는 것이다.")]),t._v(" "),i("li",[t._v("그리고 각각의 연결된 데이터를 tuple이라고 한다.")])]),t._v(" "),i("h4",{attrs:{id:"정리해보자면"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#정리해보자면"}},[t._v("#")]),t._v(" 정리해보자면")]),t._v(" "),i("ul",[i("li",[t._v("수학에서 말하는 관계란 cartesian product의 부분집합이다.")]),t._v(" "),i("li",[t._v("혹은 tuple들의 set(집합)이다.")])]),t._v(" "),i("h2",{attrs:{id:"relation-in-methemetics-relational-data-model"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#relation-in-methemetics-relational-data-model"}},[t._v("#")]),t._v(" Relation in methemetics & Relational data model")]),t._v(" "),i("img",{attrs:{src:e(468),alt:"math_in_relation",height:"250"}}),t._v(" "),i("ul",[i("li",[t._v("relational data model에서 elements 혹은 값들의 Set(집합)을 도메인이라고 부르며")]),t._v(" "),i("li",[t._v("relational data model에서도 tuple을 가질수 있고 집합마다 이름을 붙일 수 있다.")]),t._v(" "),i("li",[t._v("위와 같은 이미지 전체를 relational data model에서 relation이라고 부른다.")])]),t._v(" "),i("h3",{attrs:{id:"student-relation"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#student-relation"}},[t._v("#")]),t._v(" Student relation")]),t._v(" "),i("h4",{attrs:{id:"domain-definition"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#domain-definition"}},[t._v("#")]),t._v(" domain definition")]),t._v(" "),i("p",[t._v("student_ids : 학번 집합, 7자리 integer 정수"),i("br"),t._v("\nhuman_names : 사람 이름 집합, 문자열"),i("br"),t._v("\nuniversity_grades : 대학교 학년 집합, {1, 2, 3, 4}"),i("br"),t._v("\nmajor_names : 대학교에서 배우는 전공 이름 집합"),i("br"),t._v("\nphone_numbers : 휴대폰 번호 집합")]),t._v(" "),i("h4",{attrs:{id:"domain-of-student-relation"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#domain-of-student-relation"}},[t._v("#")]),t._v(" Domain of student relation")]),t._v(" "),i("p",[t._v("그런데 만약 어느 한 학생이 출석을 하지 않아 가족이나 주변 사람에게 연락을 하기 위한 도메인 필요하게 되었다. 그래서 동일하게 휴대폰 번호로 된 도메인을 만들었는데 이렇게 되면 동일한 도메인이 2개가 생기는 것이다. 이때 relation data model에서는 attribute라는 개념을 사용하게 된다. 수행하는 역할에 따라 이름을 붙여주는 것이다."),i("br"),t._v(" "),i("img",{attrs:{src:e(469),alt:"attribute",height:"150"}})]),t._v(" "),i("h4",{attrs:{id:"table"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#table"}},[t._v("#")]),t._v(" Table")]),t._v(" "),i("p",[t._v("이 이미지는 한 학생의 튜플을 가시적으로 표현한 것이다.\n"),i("img",{attrs:{src:e(470),alt:"tuple",height:"150"}})]),t._v(" "),i("p",[t._v("이러한 튜플을 보기좋게 표현한 것이 바로 테이블 구조이다. 테이블 구조로 바뀐 relation은 다음과 같다.\n"),i("img",{attrs:{src:e(471),alt:"student_relation",height:"250"}})]),t._v(" "),i("h2",{attrs:{id:"주요-개념-정리"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#주요-개념-정리"}},[t._v("#")]),t._v(" 주요 개념 정리")]),t._v(" "),i("h3",{attrs:{id:"relation-data-model"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#relation-data-model"}},[t._v("#")]),t._v(" Relation data model")]),t._v(" "),i("img",{attrs:{src:e(472),alt:"conclusion",height:"300"}}),t._v(" "),i("h3",{attrs:{id:"relation-schema"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#relation-schema"}},[t._v("#")]),t._v(" Relation schema")]),t._v(" "),i("ul",[i("li",[t._v("relation의 구조를 나타낸다.")]),t._v(" "),i("li",[t._v("relation 이름과 attributes 리스트로 표기된다.")]),t._v(" "),i("li",[t._v("attributes와 관련된 constraints도 포함한다.")]),t._v(" "),i("li",[t._v("ex.STUDENT(id, name, grade, major, phone_num, emer_phone_num)")])]),t._v(" "),i("h3",{attrs:{id:"degree-of-a-relation"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#degree-of-a-relation"}},[t._v("#")]),t._v(" degree of a relation")]),t._v(" "),i("ul",[i("li",[t._v("relation schema에서 attributes의 수")]),t._v(" "),i("li",[t._v("ex.STUDENT(id, name, grade, major, phone_num, emer_phone_num) 이 경우 degree 6")])]),t._v(" "),i("h3",{attrs:{id:"relation-of-relation-state"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#relation-of-relation-state"}},[t._v("#")]),t._v(" Relation (of relation state)")]),t._v(" "),i("p",[t._v("이전 글에서 state를 언급한 적이 있는데 state는 변할 수 있는 값 혹은 실제 데이터를 의미하는 단어이다. 그러나 우리가 실제로 사용할 때는 state라는 말도 쓰지만 relation이라고 하는 경우가 있으니 사용할 때 유의해야한다.")]),t._v(" "),i("h3",{attrs:{id:"relational-database"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#relational-database"}},[t._v("#")]),t._v(" Relational database")]),t._v(" "),i("p",[t._v("relational database는 위에서 정리한 relational data model에 기반하여 구조화된 database이며 relational database는 여러 개의 relations로 구성된다.")]),t._v(" "),i("h3",{attrs:{id:"relational-database-schema"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#relational-database-schema"}},[t._v("#")]),t._v(" Relational database schema")]),t._v(" "),i("p",[t._v("여기서 스키마는 relation schemas set과 relation이 여러개가 있기 때문에 integrity constraints set와 함께 구성된다.")]),t._v(" "),i("h2",{attrs:{id:"relation의-특징들"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#relation의-특징들"}},[t._v("#")]),t._v(" relation의 특징들")]),t._v(" "),i("table",[i("thead",[i("tr",[i("th",{staticStyle:{"text-align":"left"}},[t._v("특징")])])]),t._v(" "),i("tbody",[i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("relation은 중복된 tuple을 가질 수 없다. 그 이유는 relation은 set의 tuple이기 때문")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("relation의 tuple을 식별하기 위해 attribute의 부분 집합을 key로 설정한다 (id 집합)")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("relation에서 tuple의 순서는 중요하지 않다")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("하나의 relation에서 attribute의 이름은 중복되면 안된다")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("하나의 tuple에서 attribute의 순서는 중요하지 않다")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("attribute는 atomic해야한다 (더이상 나눠질 수 없는 값이어야 한다.)")])])])]),t._v(" "),i("h3",{attrs:{id:"null의-의미"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#null의-의미"}},[t._v("#")]),t._v(" NULL의 의미")]),t._v(" "),i("ul",[i("li",[t._v("값이 존재하지 않는다")]),t._v(" "),i("li",[t._v("값이 존재하나 아직 그 값이 무엇인지 알지 못한다")]),t._v(" "),i("li",[t._v("해당 사항과 관련이 없다")])]),t._v(" "),i("h3",{attrs:{id:"keys"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#keys"}},[t._v("#")]),t._v(" keys")]),t._v(" "),i("h4",{attrs:{id:"superkey"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#superkey"}},[t._v("#")]),t._v(" superkey")]),t._v(" "),i("ul",[i("li",[i("code",[t._v("relation에서 tuple을 unique하게 식별할 수 있는 attributes set")]),t._v("을 의미한다")]),t._v(" "),i("li",[t._v("ex. PLAYER(id, name, team_id, back_number, birth_date)의 수퍼키는 {id, name, team_id, back_number, birth_date}, {id, name}, {name, team_id, back_number}...이 될 수 있다.")])]),t._v(" "),i("h4",{attrs:{id:"candidate-key"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#candidate-key"}},[t._v("#")]),t._v(" candidate key")]),t._v(" "),i("ul",[i("li",[i("code",[t._v("어느 한 attribute라도 제거하면 unique하게 tuples를 식별할 수 없는 super key")]),t._v("를 말한다")]),t._v(" "),i("li",[t._v("key or minimal superkey")]),t._v(" "),i("li",[t._v("ex. PLAYER(id, name, team_id, back_number, birth_date)의 candidate key는 {id}, {team_id, back_number}가 있겠다")])]),t._v(" "),i("h4",{attrs:{id:"primary-key"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#primary-key"}},[t._v("#")]),t._v(" primary key")]),t._v(" "),i("ul",[i("li",[i("code",[t._v("relation에서 tuples를 unique하게 식별하기 위해 선택된 candidate key")])]),t._v(" "),i("li",[t._v("보통은 attribute 수가 적은 candidate key로 primary key를 사용한다")]),t._v(" "),i("li",[t._v("ex. PLAYER(id, name, team_id, back_number, birth_date)의 primary key는 {id}, {team_id, back_number}가 된다")])]),t._v(" "),i("h4",{attrs:{id:"unique-key"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#unique-key"}},[t._v("#")]),t._v(" unique key")]),t._v(" "),i("ul",[i("li",[i("code",[t._v("primary key가 아닌 candidate keys")])]),t._v(" "),i("li",[t._v("alternate key")]),t._v(" "),i("li",[t._v("ex. PLAYER(id, name, team_id, back_number, birth_date)의 unique key는 {team_id, back_number}가 된다")])]),t._v(" "),i("h4",{attrs:{id:"foreign-key"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#foreign-key"}},[t._v("#")]),t._v(" foreign key")]),t._v(" "),i("ul",[i("li",[i("code",[t._v("다른 relation의 PK(primary key)를 참조하는 attibutes set")]),t._v("을 말한다.")]),t._v(" "),i("li",[t._v("ex. 도메인이 PLAYER(id, name, team_id, back_number, birth_date)와 TEAM(id, name, manager)라고 했을 때 foreign key는 PLAYER의 {team_id}가 된다")])]),t._v(" "),i("h3",{attrs:{id:"constraints-뜻"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#constraints-뜻"}},[t._v("#")]),t._v(" constraints 뜻")]),t._v(" "),i("p",[t._v("relational database의 relations들이 언제나 항상 지켜줘야 하는 제약사항을 말한다. database가 항상 일치된 형태로 그리고 데이터의 일관성을 보장하기 위해 사용되는 개념이다")]),t._v(" "),i("h4",{attrs:{id:"implicit-constraints"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#implicit-constraints"}},[t._v("#")]),t._v(" implicit constraints")]),t._v(" "),i("ul",[i("li",[t._v("relational data model 자체가 가지는 contraints")]),t._v(" "),i("li",[t._v("relation은 중복되는 tuple을 가질 수 없다")]),t._v(" "),i("li",[t._v("relation 내에서는 같은 이름의 attibute를 가질 수 없다")])]),t._v(" "),i("h4",{attrs:{id:"schema-based-constraints"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#schema-based-constraints"}},[t._v("#")]),t._v(" schema-based constraints")]),t._v(" "),i("ul",[i("li",[t._v("주로 DDL을 통해 schema에 직접 명시할 수 있는 constraints")]),t._v(" "),i("li",[t._v("explicit constraints")]),t._v(" "),i("li",[t._v("이 제약 사항에는 여러 종류가 존재한다.")])]),t._v(" "),i("table",[i("thead",[i("tr",[i("th",{staticStyle:{"text-align":"left"}},[t._v("제약사항")]),t._v(" "),i("th",{staticStyle:{"text-align":"left"}},[t._v("내용")])])]),t._v(" "),i("tbody",[i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("domain constraints")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("attribute의 value는 해당 attribute의 domain에 속한 value여야한다.")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("key constraints")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("서로 다른 tuples는 같은 value의 key를 가질 수 없다.")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("NULL value constraint")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("attibute가 NOT NULL로 명시됐다면 NULL을 값으로 가질 수 없다.")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("entity integrity contraint")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("primary key는 value에 NULL을 가질 수 없다.")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("referential integrity constraint")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("FK와 PK와 도메인이 같아야 하고 PK에 없는 values를 FK가 값으로 가질 수 없다.")])])])])])}),[],!1,null,null,null);a.default=r.exports}}]);