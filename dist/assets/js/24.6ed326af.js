(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{499:function(t,s,a){t.exports=a.p+"assets/img/three_value.9bbeaf64.png"},500:function(t,s,a){t.exports=a.p+"assets/img/unknown.36efd7df.png"},501:function(t,s,a){t.exports=a.p+"assets/img/not_in.f0841313.png"},564:function(t,s,a){"use strict";a.r(s);var e=a(25),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"sql에서의-null"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sql에서의-null"}},[t._v("#")]),t._v(" SQL에서의 NULL")]),t._v(" "),e("h2",{attrs:{id:"개요"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#개요"}},[t._v("#")]),t._v(" 개요")]),t._v(" "),e("p",[t._v("SQL에서의 NULL의 의미는 다양한 의미를 가질 수 있는데 예를 들면 다음과 같다."),e("br"),t._v(" "),e("b",[t._v("unknown")]),e("br"),t._v("\n해당 값이 아직 알려지지 않았을 때")]),t._v(" "),e("p",[e("b",[t._v("unavailable or withheld")]),e("br"),t._v("\n정보를 공개하지 않아 정보를 이용할 수 없을 때")]),t._v(" "),e("p",[e("b",[t._v("not applicable")]),e("br"),t._v("\n해당 사항이 없을 때")]),t._v(" "),e("h2",{attrs:{id:"is"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#is"}},[t._v("#")]),t._v(" IS")]),t._v(" "),e("p",[t._v("만약 테이블에서 어떠한 속성 값이 NULL인 데이터를 가져오고 싶을 때는 "),e("code",[t._v("=")]),t._v("와 같은 연산자를 사용하면 안되고 "),e("code",[t._v("IS")]),t._v("를 사용해야한다. 이때 "),e("code",[t._v("=")]),t._v("을 사용하게 되면 아무런 값이 조회되지 않는다.")]),t._v(" "),e("div",{staticClass:"language-SQL extra-class"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" id \n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" employee\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" birth_date "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("IS")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("h2",{attrs:{id:"null과-three-valued-logic"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#null과-three-valued-logic"}},[t._v("#")]),t._v(" NULL과 Three-Valued Logic")]),t._v(" "),e("p",[t._v("SQL에서 NULL과 비교 연산을 하게 되면 그 결과는 UNKNOWN이다. "),e("code",[t._v("UNKNOWN은 'TRUE일수도 있고 FALSE수도 있다'")]),t._v(" 라는 의미이며 Three-Valued Logic은 비교/논리 연산의 결과로 "),e("code",[t._v("TRUE, FALSE, UNKNOWN")]),t._v("을 가진다. 아래는 비교 연산의 결과와 논리 연산을 NULL과 하게 될 경우에 대한 정리표이다.")]),t._v(" "),e("img",{attrs:{src:a(499),alt:"three_value",height:"300"}}),t._v(" "),e("img",{attrs:{src:a(500),alt:"unknown",height:"300"}}),t._v(" "),e("h3",{attrs:{id:"그런데-이게-왜-중요한가"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#그런데-이게-왜-중요한가"}},[t._v("#")]),t._v(" 그런데 이게 왜 중요한가?")]),t._v(" "),e("p",[t._v("바로 조건절 때문인데. where절에 있는 condition(s)의 결과는 TRUE인 tuple(s)만 선택된다. 즉, 결과가 FALSE거나 UNKNOWN이면 tuple은 선택되지 않는다는 말이다. 만약 v NOT IN (v1, v2, v3)라는 쿼리가 있을 때 해당 쿼리를 풀어쓰면 다음과 같은데 v != v1, v != v2, v != v3 이때 하나라도 값이 NULL이라면 어떻게 될까?")]),t._v(" "),e("img",{attrs:{src:a(501),alt:"not_in",height:"200"}}),t._v(" "),e("p",[t._v("위의 이미지에서 제일 마지막 예시는 NULL을 잘 모르고 사용한다면 1번과 같은 결과가 나올것이라 예상하지만 4번의 예시를 풀어 쓴다면\n3 != 1, 3 != 2, 3 != NULL이게 된다. 이때 값은 UNKNOWN이 나온다고 위에서 확인했다. 그러면 결과적으로 우리는 예상한 데이터를 받을 수 없게되고 해당 데이터는 정확하지 않다는 말이다. 쿼리를 통해서 다시 확인해보자.")]),t._v(" "),e("div",{staticClass:"language-SQL extra-class"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" D"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("id"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" D"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("namd\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" dapartment "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" D\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" D"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("in")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("NOT")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("IN")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" E"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("dept_id\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" employee "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" E\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" E"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("birth_date "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2000-01-01'")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[t._v("이런 쿼리가 있다고 했을 떄 만약 birth_date은 NULL을 가질 수 있다는 정책을 가지고 있을 경우 이 값이 하나라도 널이라면 반환되는 서브쿼리 값은 FALSE 또는 UNKNOWN이 될 것이다. 그러므로 outer query의 NOT IN과 비교하게 되면 where 절은 TRUE의 값을 반환하기 때문에 결국 아무런 값도 받을 수 없다는 뜻이다, 2000대 생이 있음에도 불구하고 말이다. 그러면 어떻게 해결해야하나? 두가지 쿼리가 있다. 하나는 가장 많이 쓰는 IS NOT NULL과 EXISTS를 사용하는 방법이다.")]),t._v(" "),e("div",{staticClass:"language-SQL extra-class"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" D"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("id"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" D"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("namd\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" dapartment "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" D\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" D"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("in")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("NOT")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("IN")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" E"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("dept_id\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" employee "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" E\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" E"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("birth_date "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2000-01-01'")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" E"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("dept_id "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("IS")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("NOT")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("div",{staticClass:"language-SQL extra-class"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" D"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("id"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" D"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("namd\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" dapartment "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" D\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" D"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("in")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("NOT")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("EXISTS")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" employee "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" E\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" E"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("dept_id "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" D"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("id \n        "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" E"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("birth_date "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2000-01-01'")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("h2",{attrs:{id:"마무리"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#마무리"}},[t._v("#")]),t._v(" 마무리")]),t._v(" "),e("p",[t._v("오늘 배운 내용은 정말 중요하다고 생각한다. RDBMS마다 조금 다를 수 있을 거라고 생각지만 정신없이 일하고 있을 때 해당 로직을 알지 못하고 작업을 한다면 내가 많든 로직에서 정말 이상한 값을 반환해줄 수 있기 때문이다. 어쩌면 3년 동안 일하면서 나도 실수를 했을지도 모르겠다. IS NOT NULL이라는 친구를 더 가까이 생각해둬야 할 것 같다.")])])}),[],!1,null,null,null);s.default=n.exports}}]);