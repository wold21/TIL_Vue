(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{513:function(e,t,r){e.exports=r.p+"assets/img/reliable_protocol.f55f768d.png"},514:function(e,t,r){e.exports=r.p+"assets/img/bite-stream,message-oriented.8d0e5266.png"},589:function(e,t,r){"use strict";r.r(t);var o=r(25),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"byte-stream-protocol과-message-oriented-protocol의-차이"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#byte-stream-protocol과-message-oriented-protocol의-차이"}},[e._v("#")]),e._v(" byte-stream protocol과 message-oriented protocol의 차이")]),e._v(" "),o("h2",{attrs:{id:"개요"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#개요"}},[e._v("#")]),e._v(" 개요")]),e._v(" "),o("p",[e._v("TCP와 UDP를 각각 byte-stream protocol과 message-oriented protocol이라고 부른다. 그 이유와 동작 방식에 대해서 알아보려고 한다.")]),e._v(" "),o("h2",{attrs:{id:"udp-message-oriented-protocol"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#udp-message-oriented-protocol"}},[e._v("#")]),e._v(" UDP - message-oriented protocol")]),e._v(" "),o("p",[e._v("UDP는 internet protocol과 거의 유사하게 동작하기 때문에 전송 중 데이터가 유실되거나 순서가 바뀌는 경우가 발생하나, 그런 문제없이 잘 전달된다고 가정을 해보겠다.")]),e._v(" "),o("p",[e._v("한 호스트에서 다른 호스트로 각각 4byte, 8byte, 3byte의 데이터를 보내면 도착지 호스트의 transport layer에서 메시지를 잘 구분하여 application layer로 데이터를 잘 보내주게 된다. 이때 출발지 호스트에서 전송 함수를 통해 각 3개의 "),o("code",[e._v("메시지")]),e._v("를 보내면 받는 쪽에서도 받는 함수를 3번 호출하여 메시지를 읽게 되게되는데 이게 message-oriented protocol의 큰 특징이다.")]),e._v(" "),o("ul",[o("li",[e._v("보낸 메시지 단위 그대로 받을 수 있게 해주는 프로토콜")]),e._v(" "),o("li",[e._v("메시지 간의 경계를 구분할 수 있음")]),e._v(" "),o("li",[e._v("한번에 전송 가능한 메시지의 최대 크기가 존재함")])]),e._v(" "),o("h2",{attrs:{id:"tcp-byte-stream-protocol"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#tcp-byte-stream-protocol"}},[e._v("#")]),e._v(" TCP - byte-stream protocol")]),e._v(" "),o("p",[e._v("TCP는 UDP처럼 4byte, 8byte, 3byte와 같은 데이터를 보낼 때 메시지의 경계나 구분에 관심이 없고 보내려는 데이터를 byte들의 흐름이라고 인식하고 전송합니다. 그러면 TCP는 이 byte들을 어떤 단위로 전송할까. 바로 이전에 배웠던 TCP segment이다. 정리해보자면")]),e._v(" "),o("ul",[o("li",[e._v("TCP는 신뢰할 수 있는 데이터 전송을 실현하는 것이 목적이다.")]),e._v(" "),o("li",[e._v("애플리케이션에서 보낸 메시지와는 독립적으로 특정 크기로 구분되는 별도의 전송단위를 통해 데이터를 전송한다.")]),e._v(" "),o("li",[e._v("이 단위를 "),o("code",[e._v("TCP segment")]),e._v("라고 부른다.")]),e._v(" "),o("li",[e._v("특정크기에 대한 개념은 다음과 같다.\n"),o("ul",[o("li",[o("code",[e._v("MSS(Maximum Segment Size)")])]),e._v(" "),o("li",[e._v("정의한 MSS값보다 크면 segment를 분리한다.")])])])]),e._v(" "),o("p",[e._v("그런데 만약 MSS의 크기가 널널해서 15byte를 한번에 보낼 수 있게 되었고 해당 데이터를 도착지 애플리케이션에서 사용하면 된다. 아까는 클라이언트에서 3번에 나누어 데이터를 보내고 받았는데 TCP로 보낼 때 또한 출발지 호스트는 3번에 나누어 보냈다. 그런데 MSS의 값이 널널해서 한번에 보냈는데 그럼 받는 쪽에서는 메시지를 어떻게 구분해야할까? 이때 이 책임은 byte-stream protocol에 있지 않다. 이 프로토콜을 사용하는 쪽에서 담당한다고 한다. 예를들어 MSS가 1kb라면 최대 1kb만큼의 byte를 한번에 읽을 수 있다는 것이다. 동작을 좀 더 정리해보면")]),e._v(" "),o("ul",[o("li",[e._v("사용하는 쪽에서 전송한 메시지를 구분하지 않음")]),e._v(" "),o("li",[e._v("데이터 전송을 "),o("code",[e._v("byte들의 흐름 관점")]),e._v("으로만 접근")]),e._v(" "),o("li",[o("code",[e._v("메시지를 구분하는 책임은 해당 프로토콜을 사용하는 쪽에 있음")])])]),e._v(" "),o("h2",{attrs:{id:"질문"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#질문"}},[e._v("#")]),e._v(" 질문")]),e._v(" "),o("p",[o("b",[e._v("1. Byte-stream protocol은 reliable한가?")]),o("br"),e._v("\nreliable한지 여부와 독립적인 개념이다.\n"),o("img",{attrs:{src:r(513),alt:"reliable_protocol",height:"150"}})]),e._v(" "),o("p",[o("b",[e._v("2. UDP를 통해 max UDP datagram size보다 큰 메시지를 전송하려면 어떻게 되는가?")])]),e._v(" "),o("p",[e._v("이때는 실패하고 에러를 받는다. 에러에 대해서 어떻게 처리할지는 개발자나 application-layer protocol이 구현해야한다.")]),e._v(" "),o("p",[o("b",[e._v("3. TCP를 통해 MSS보다 큰 메시지를 전송하려면 어떻게 되는가?")]),o("br"),e._v("\nTCP가 알아서 MSS에 맞는 TCP segment로 나누어서 전송한다.")]),e._v(" "),o("p",[o("b",[e._v("4. byte-stream protocol을 사용하는 쪽에서 메시지를 구분하는 방법은 어떤 것들이 있나요?")]),o("br"),e._v("\n방법은 여러가지가 있다.")]),e._v(" "),o("ul",[o("li",[e._v("메시지 사이즈를 고정한다.")]),e._v(" "),o("li",[e._v("메시지 사이즈를 먼저 보낸 후 메시지를 보낸다.")]),e._v(" "),o("li",[e._v("메시지 사이에 구분자를 넣어서 전송한다. (ex. CRLF)\n"),o("ul",[o("li",[e._v("Carriage Return / Line Feed")])])])]),e._v(" "),o("p",[o("b",[e._v("5. TCP가 byte-stream protocol이라면 TCP 위에서 동작하는 HTTP는 자체적으로 HTTP message의 경계를 구분하는 방법을 가지고 있다는 말인가?")]),o("br"),e._v("\n정답은 그렇다. 그러나 HTTP버전에 따라 달라지는 부분이 있기 때문에 사용하는 버전에 따라 확인해봐야한다.")]),e._v(" "),o("h2",{attrs:{id:"마무리"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#마무리"}},[e._v("#")]),e._v(" 마무리")]),e._v(" "),o("img",{attrs:{src:r(514),alt:"bite-stream,message-oriented",height:"300"}})])}),[],!1,null,null,null);t.default=a.exports}}]);